
# Spring Boot Practice
This repository contains my practice with **Spring Boot** as I learn its core features and functionalities. I'm following the tutorial video **[“Building web applications in Java with Spring Boot 3 – Tutorial”](https://www.youtube.com/watch?v=31KTdfRH6nY)** by **[@Dan Vega](https://github.com/danvega)** , which provides a step-by-step guide to building and understanding Spring Boot applications. Throughout this project, I'll be documenting key concepts, code implementations, and any challenges I encounter as I explore dependency injection, REST APIs, data persistence, and more. Each commit represents a new learning milestone, with updates to both the code and my understanding of Spring Boot.

# Development Environment
-   **IDE:** IntelliJ IDEA
-   **Java Version:** Java 21
-   **Spring Boot Version:** 3.4.4
- **Build Tool:** Maven

# Features Learned
**General**

 - **`mvn spring-boot:run`** runs the Spring Boot application with all the Spring setup (including annotations and dependency injection), whereas **`mvn exec:java`** is for standard Java programs without Spring Boot’s special configuration.

 - **Spring Boot annotations** like `@SpringBootApplication`, `@RestController`, and `@Component` are special keywords we put above classes or methods in a Java program to tell the Spring Boot framework how to treat them. On their own, these annotations don’t do anything, Java by itself doesn’t understand them. But when we use Spring Boot, it looks at these annotations and sets up the program based on what they mean. For example, let say in a kitchen with a lot of different spoons we can't tell their uses but we can know their use if there is a label on it, just like in Spring Boot annotations is like a labels that guide Spring Boot to build and run the application correctly behind the scenes.

 - **`@SpringBootApplication`** marks the main class of a Spring Boot application. It tells Spring Boot to start the application, initialize configuration, enable component scanning, and apply default auto-configuration settings. If this annotation is missing, Spring Boot-specific features won’t work automatically. However, the application could still work if all configurations are set up manually using standard Spring annotations like `@Configuration`, `@ComponentScan`, and `@EnableAutoConfiguration`.
 - **`public static void main(String[] args) {  
    SpringApplication.run(ApplicationName.class, args);  
}`** When you compile a Java application, the JVM looks for the `main` method as the entry point. Inside the `main` method, `SpringApplication.run()` is called, which initializes the Spring Boot framework. It processes the `ApplicationName.class` to find configuration annotations like `@SpringBootApplication` and sets up the application context, including auto-configuration and beans. The `args` parameter is passed to Spring Boot, allowing you to handle command-line arguments. Essentially, Spring Boot is started through this line, and the application begins running with all the necessary configurations applied.

**REST API**

 - **`@RestController`** is used in Spring Boot to create RESTful APIs. It handles HTTP requests like GET, POST, PUT, and DELETE, and returns data (usually in JSON format) directly in the response body instead of rendering a view. This annotation combines `@Controller` and `@ResponseBody`, making it ideal for backend services where you only need to send and receive data between the client and server.
 - Mapping with `@RequestMapping` (or its shortcuts like `@GetMapping`, `@PostMapping`, etc.) defines the URL that the frontend uses to communicate with the backend. The full URL starts with the server address (like `http://localhost:8080`) followed by the mapped path (e.g., `/users`). When the frontend sends a request to that URL, Spring looks for a method with a matching mapping annotation. These annotations must be placed on the method (and optionally the class) that should handle the request. For example, if the frontend sends a GET request to `http://example.com`, Spring will match it to a method annotated with `@GetMapping("/")`, and the method’s return value (typically JSON) will be sent back in the response body for the frontend to use.
 - **`@RequestMapping("")`** is used to map HTTP requests to a specific method or class in a controller. It defines the URL path that triggers the method. If used on a class, it sets a base path for all methods inside. If used on a method, it maps a specific path or action. Without any value, `@RequestMapping("")` maps to the root path (`/`). You can also specify request types using `method = RequestMethod.GET` or similar. It's more general; for simpler use, you can use `@GetMapping`, `@PostMapping`, etc. which are shortcuts for common request types.
 - **`@GetMapping("")`** is used to handle HTTP GET requests. If the value is empty (`""`), it maps to the root path (`"/"`), meaning it will respond to requests like `http://example.com/`. If placed inside a class with `@RequestMapping("/api")`, the full path becomes `http://example.com/api/`. The method under this annotation handles the request and returns a response, usually as JSON, which is sent in the response body.
 - **`@PostMapping("")`** handles HTTP POST requests, usually used when the frontend wants to send data to the backend, like creating a new record. If the value is empty, it maps to the root path (`"/"`), or it can be combined with a base path from `@RequestMapping`. The method under this annotation reads data from the request body (like JSON) and returns a response, often confirming the creation.
 - **`@PutMapping("")`** is used for HTTP PUT requests, typically to update existing data. It works like `@PostMapping` but is meant for updates instead of creation. The method takes the updated data from the request body and processes it. The path can be the root or a specific one, often including an ID (e.g., `/users/1`) to indicate what should be updated.
 - **`@DeleteMapping("")`** handles HTTP DELETE requests, used when the frontend wants to delete data from the backend. The method usually doesn’t need a request body, just the URL with the identifier (like `/users/1`). The backend processes the request and returns a response confirming the deletion.
 - **`@ResponseStatus()`** is used to set the HTTP status code for a response in Spring. It is commonly used in methods that handle POST, PUT, and DELETE requests. While the mapping annotations like `@PostMapping`, `@PutMapping`, and `@DeleteMapping` handle the HTTP request, **`@ResponseStatus()`** specifies the HTTP status code that will be returned in the response. You can use predefined status codes like `HttpStatus.CREATED` (for a successful POST request) or `HttpStatus.NO_CONTENT` (for a successful DELETE request). This helps to provide more context about the result of the operation.

